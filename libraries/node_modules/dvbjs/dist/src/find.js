"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const utils = __importStar(require("./utils"));
async function pointFinder(name, stopsOnly, assignedStops, timeout) {
    if (typeof name !== "string") {
        throw utils.constructError("ValidationError", "query has to be a string");
    }
    const stopName = name.trim();
    const options = {
        url: "https://webapi.vvo-online.de/tr/pointfinder",
        params: {
            format: "json",
            stopsOnly,
            assignedStops,
            limit: 0,
            query: stopName,
            dvb: true,
        },
        timeout,
    };
    return axios_1.default(options)
        .then((response) => {
        // check status of response
        utils.checkStatus(response.data);
        const result = [];
        if (response.data.Points) {
            response.data.Points.forEach((p) => {
                const poi = p.split("|");
                const coords = utils.WmOrGK4toWGS84(poi[5], poi[4]);
                const pointName = poi[3].replace(/'/g, "");
                if (pointName && coords) {
                    const city = poi[2] === "" ? "Dresden" : poi[2];
                    const { id, type } = utils.parsePoiID(poi[0]);
                    result.push({
                        city,
                        coords,
                        name: pointName,
                        id,
                        type,
                    });
                }
            });
        }
        return result;
    })
        .catch(utils.convertError);
}
/**
 * Search for a single stop in the network of the DVB.
 * @param searchString the name of the stop
 * @param timeout the timeout of the request
 * @returns an array of all possible hits including their GPS coordinates.
 */
function findStop(searchString, timeout = 5000) {
    return pointFinder(searchString, true, false, timeout);
}
exports.findStop = findStop;
/**
 * Search for POI in the network of the DVB.
 * @param searchString the name of the stop
 * @param timeout the timeout of the request
 * @returns an array of all possible hits including their GPS coordinates.
 */
function findPOI(searchString, timeout = 5000) {
    return pointFinder(searchString, false, false, timeout);
}
exports.findPOI = findPOI;
/**
 * Lookup address and nearby stops by coordinate.
 * @param lng longitude of the coordinate
 * @param lat latitude of the coordinate
 * @param timeout the timeout of the request
 * @returns the adress and neaby stops
 */
function findAddress(lng, lat, timeout = 5000) {
    const gk4 = utils.WGS84toGK4(lng, lat);
    return pointFinder(`coord:${gk4[0]}:${gk4[1]}`, false, true, timeout).then((points) => {
        if (points.length === 0) {
            return undefined;
        }
        const address = Object.assign(Object.assign({}, points[0]), { stops: points.slice(1) || [] });
        return address;
    });
}
exports.findAddress = findAddress;
